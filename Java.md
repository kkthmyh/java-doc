

##  1.Java基础

###  1.1 ArrayList的扩容机制

###  1.2 String

- 不可变，底层是final修饰的char数组，不变的主要作用是当一个对象要被多线程共享并频繁访问时可以保证数据的一致性
- 常量池优化，String对象创建后会在字符串常量池中进行缓存，下次创建同样对象时，会直接从缓存返回应用
- final，String不可被继承，提高系统的安全性

###  1.3 有没有用过TreeMap，HashMap的put原理，CurrentHashMap实现原理

####  1.3.1 hash函数

``(h = key.hashCode()) ^ (h >>> 16)``

````
为什么要右移？
0000 0000 0001 0000 0000 0000 0000 0000      #key的hashCode
                    0000 0000 0001 0000 0000 0000 0000 0000     #key右移
让hashCode的高16位和低16位都参与运算，保证散列性
````

key的hash值和其右移动16位，为的是保证hash函数的散列性，将高位向低位移动

####  1.3.2 为什么HashMap的容量要是2的n次幂

因为计算元素放置位置的计算方法为``i = (n - 1) & hash``，其中n为数组的长度

例如10 mod 8 余数为2，转为二进制如下

````
	 0000 0000 0000 0000 0000 0000 0000 1010    #10
 ÷   0000 0000 0000 0000 0000 0000 0000 1000    #8
	
	# 一个数除以2^n，相当于其二进制位右移n位，余数为移动后的数
	即为010=2
	
	# 由上可以推导出，整数x除以2^n的结果为整数的二进制数的后n位
	0000 0000 0000 0000 0000 0000 0000 1010    #10
  & 0000 0000 0000 0000 0000 0000 0000 0111    #7
	0000 0000 0000 0000 0000 0000 0000 0010    #2

	
````

2^n 次幂如8 16 32 等，n-1转为二进制就是111 1111 11111，进行与运算时候只看后几位，可以减少hash碰撞

只有是2的n次幂才能进行按位运算来代替取模运算、

####  1.3.3 HashMap的put原理

- 对 key 的 hashCode () 进行 hash 后计算数组获得下标 index;
- 如果当前数组为 null，进行容量的初始化，初始容量为 16；
- 如果 hash 计算后没有碰撞，直接放到对应数组下标里；
- 如果 hash 计算后发生碰撞且节点已存在，则替换掉原来的对象；
- 如果 hash 计算后发生碰撞且节点已经是树结构，则挂载到树上。
- 如果 hash 计算后发生碰撞且节点是链表结构，则添加到链表尾，并判断链表是否需要转换成树结构（默认大于 8 的情况会转换成树结构）；
- 完成 put 后，是否需要 resize () 操作（数据量超过 threshold，threshold 为初始容量和负载因子之积，默认为 12）。

####  1.3.4 resize()方法

- 首次扩容
  - 无参构造下，如果是首次扩容，直接创建一个大小为初始容量16的Node数组
  - 带参构造指定初始值的情况下，将创建大于等于此值2的幂值大小的Node数组
- 不是首次扩容
  - 循环遍历数组长度，当节点位置不为null，将其赋值给临时变量e，并将其置为null，
  - 如果e.next==null，证明是单节点，将e赋值给newTab[e.hash&(newCap-1)]
  - 如果e instanceof TreeNode，进行红黑树处理
  - 

###  1.4 线程生命周期，线程池参数，有哪几种拒绝策略，如何设置线程池中的参数

###  1.5 JUC包下的常用类和使用场景，聊聊AQS

###  1.6 聊聊volatile和synchronized

##  2 JVM

###  2.1 JVM内存的各个分区及其作用

###  2.2 垃圾回收算法

###  2.3 垃圾如何识别，其中可达性分析中以哪些对象作为GCROOT

###  2.4 有哪些垃圾收集器，聊一下CMS和G1

###  2.5 年轻代用什么垃圾回收算法，老年代用什么垃圾回收算法以及原因

###  2.6 线上频繁出现fullgc和OOM情况怎么定位问题

###  2.7类加载机制

##  3 中间件

###  3.1 redis为什么是单线程的

###  3.2 redis的字符类型底层实现

###  3.3 redis做分布式锁要注意什么

###  3.4 雪崩、击穿的解决方案

###  3.5 Mysql的存储引擎

###  3.6 索引结构，为什么是B+不是B，B+一般几层

###  3.7 索引覆盖、索引下推

###  3.8 数据库事务，mysql如何解决幻读问题

###  3.9 执行计划中有哪些比较重要的参数

###  3.10 sql中的最左匹配原则

###  3.11 mysql的binlog、undolog、redolog

##  4 框架

###  4.1 Spring中的控制反转理解

###  4.2 Spring的事务传播特性

###  4.3 bean的生命周期

###  4.4 Spring中用到了哪些设计模式

###  4.5 Spring怎么解决循环依赖问题





